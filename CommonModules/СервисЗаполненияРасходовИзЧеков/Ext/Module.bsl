
#Область СлужебныеПроцедурыИФункции

// Функция-конструктор данных о чеке
// 
// Возвращаемое значение:
//  Структура:
//  * Дата - Дата - Дата и время покупки
//  * Товары - ТаблицаЗначений:
//  ** Наименование - Строка - Наименование товара/услуги
//  ** Цена - Число -
//  ** Количество - Число -
Функция НовыеДанныеОЧеке() Экспорт
	ДанныеОЧеке = Новый Структура;

	ДанныеОЧеке.Вставить("Дата", Дата(1, 1, 1));

	Товары = Новый ТаблицаЗначений;

	Товары.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	Товары.Колонки.Добавить("Цена", Метаданные.ОпределяемыеТипы.ДенежнаяСуммаНеотрицательная.Тип);
	Товары.Колонки.Добавить("Количество", Метаданные.ОпределяемыеТипы.КоличествоНоменклатурыНеотрицательное.Тип);

	ДанныеОЧеке.Вставить("Товары", Товары);

	Возврат ДанныеОЧеке;
КонецФункции

Функция ДанныеОЧекеПоРеквизитам(ФН, ФД, ФП, Дата, Итог) Экспорт
	ДанныеЗапроса = Новый Структура;
	
	ДанныеЗапроса.Вставить("token", Токен());
	ДанныеЗапроса.Вставить("fn", ФН);
	ДанныеЗапроса.Вставить("fd", ФД);
	ДанныеЗапроса.Вставить("fp", ФП);
	// АПК:1367-выкл это форматирование даты для внешнего сервиса
	ДанныеЗапроса.Вставить("t", Формат(Дата, "ДФ='dd.MM.yyyy HH:mm'"));
	// АПК:1367-вкл
	ДанныеЗапроса.Вставить("n", 1);
	ДанныеЗапроса.Вставить("s", Формат(Итог, "ЧРД=.; ЧН=0; ЧГ="));
	
	СоединениеИЗапрос = НовоеСоединениеИЗапросКСервису();
	
	ДанныеОЧеке = ВыполнитьЗапросКСервису(СоединениеИЗапрос, ДанныеЗапроса);
	Возврат ДанныеОЧекеДляПередачиНаКлиент(ДанныеОЧеке);
КонецФункции

Функция ДанныеОЧекеПоФото(ДвоичныеДанныеКартинки) Экспорт
	СоединениеИЗапрос = НовоеСоединениеИЗапросКСервису();
	
	РазделительFormData = "HABoundary" + СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
	
	Поток = Новый ПотокВПамяти;
	ЗаписьДанных = Новый ЗаписьДанных(Поток,,, Символы.ВК + Символы.ПС, "", Ложь);
	
	ЗаписьДанных.ЗаписатьСтроку("--" + РазделительFormData);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""qrfile""; filename=""file.jpg""");
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: image/jpeg");
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.Записать(ДвоичныеДанныеКартинки);
	
	ЗаписьДанных.ЗаписатьСтроку("");
	
	ЗаписьДанных.ЗаписатьСтроку("--" + РазделительFormData);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""token""");
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.ЗаписатьСтроку(Токен());
	ЗаписьДанных.ЗаписатьСтроку("--" + РазделительFormData + "--");
	
	ЗаписьДанных.Закрыть();
	
	ТелоЗапроса = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	СоединениеИЗапрос.Запрос.УстановитьТелоИзДвоичныхДанных(ТелоЗапроса);
	СоединениеИЗапрос.Запрос.Заголовки.Вставить("Content-Type", "multipart/form-data, boundary=" + РазделительFormData);
	СоединениеИЗапрос.Запрос.Заголовки.Вставить("Content-Length", XMLСтрока(ТелоЗапроса.Размер()));
	
	ДанныеОЧеке = ВыполнитьЗапросКСервису(СоединениеИЗапрос);
	Возврат ДанныеОЧекеДляПередачиНаКлиент(ДанныеОЧеке);
КонецФункции

// Возвращает данные о чеке по строке содержимого QR-кода
// Пример такой строки: t=20240504T0854&s=5411.53&fn=1231440501044528&i=162148&fp=1495552153&n=1
//
// Параметры:
//  СтрокаQRКода - Строка -
// 
// Возвращаемое значение:
//  Структура - См. НовыеДанныеОЧеке()
Функция ДанныеОЧекеПоСтрокеQRКода(СтрокаQRКода) Экспорт
	ДанныеЗапроса = Новый Структура;
	
	ДанныеЗапроса.Вставить("token", Токен());
	ДанныеЗапроса.Вставить("qrraw", СтрокаQRКода);
	
	СоединениеИЗапрос = НовоеСоединениеИЗапросКСервису();
	
	ДанныеОЧеке = ВыполнитьЗапросКСервису(СоединениеИЗапрос, ДанныеЗапроса);
	Возврат ДанныеОЧекеДляПередачиНаКлиент(ДанныеОЧеке);
КонецФункции

Процедура ПроверитьТокен(НовыйТокен) Экспорт
	ДанныеЗапроса = Новый Структура;
	
	ДанныеЗапроса.Вставить("token", НовыйТокен);
	ДанныеЗапроса.Вставить("qrraw", "");
	
	СоединениеИЗапрос = НовоеСоединениеИЗапросКСервису();
	
	ВыполнитьЗапросКСервису(СоединениеИЗапрос, ДанныеЗапроса, Истина);
КонецПроцедуры

Функция НовоеСоединениеИЗапросКСервису()
	Соединение = Новый HTTPСоединение("proverkacheka.com", 443,,,
		ПолучениеФайловИзИнтернета.ПолучитьПрокси("https"), 15,
		ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение());
	//
	Запрос = Новый HTTPЗапрос("api/v1/check/get");

	Возврат Новый Структура("Соединение, Запрос", Соединение, Запрос);
КонецФункции

Функция ВыполнитьЗапросКСервису(СоединениеИЗапросКСервису, ДанныеJSON = Неопределено,
	РежимПроверкиТокена = Ложь)
	
	Соединение = СоединениеИЗапросКСервису.Соединение;
	Запрос = СоединениеИЗапросКСервису.Запрос;

	Если ДанныеJSON <> Неопределено Тогда
		Запрос.Заголовки.Вставить("Content-Type", "application/json");
		Запрос.УстановитьТелоИзСтроки(ОбщегоНазначения.ЗначениеВJSON(ДанныеJSON));
	КонецЕсли;

	HTTPОтвет = Соединение.ВызватьHTTPМетод("POST", Запрос);
	Если HTTPОтвет.КодСостояния <> 200 Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru='Сервис проверки чека вернул код состояния %1'"), HTTPОтвет.КодСостояния);
	КонецЕсли;

	СыройОтвет = ОбщегоНазначения.JSONВЗначение(HTTPОтвет.ПолучитьТелоКакСтроку(),, Ложь);
	
	Если РежимПроверкиТокена И СыройОтвет.code <> 401 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СыройОтвет.code <> 1 Тогда
		ПредставлениеОшибкиСервиса = ПредставлениеОшибкиСервиса(СыройОтвет);
		ВызватьИсключение СтрШаблон(НСтр("ru='Сервис проверки чека сообщил об ошибке'")
			+ Символы.ПС + ПредставлениеОшибкиСервиса);
		//
	КонецЕсли;

	ДанныеОЧеке = НовыеДанныеОЧеке();
	ДанныеОЧеке.Дата = XMLЗначение(Тип("Дата"), СыройОтвет.data.json.dateTime);
	
	ИсключатьСтрокиСНулевойСуммой = Константы.ИсключатьСтрокиСНулевойСуммойПриЗагрузкеРасходовИзЧека.Получить();

	Для Каждого СтрТоварыАПИ Из СыройОтвет.data.json.items Цикл
		Если СтрТоварыАПИ.price = 0 И ИсключатьСтрокиСНулевойСуммой Тогда
			Продолжить;
		КонецЕсли;
		
		СтрТоварыЧека = ДанныеОЧеке.Товары.Добавить();

		СтрТоварыЧека.Наименование = СтрТоварыАПИ.name;
		СтрТоварыЧека.Цена = СтрТоварыАПИ.price / 100;
		СтрТоварыЧека.Количество = СтрТоварыАПИ.quantity;
	КонецЦикла;
	
	ДанныеОЧеке.Товары.Свернуть("Наименование, Цена", "Количество");

	Возврат ДанныеОЧеке;
КонецФункции

Функция ПредставлениеОшибкиСервиса(СыройОтвет)
	ПредставленияКодов = Новый Соответствие;
	
	ПредставленияКодов[0] = НСтр("ru='Чек некорректен'");
	ПредставленияКодов[2] = НСтр("ru='Данные чека пока не получены'");
	ПредставленияКодов[3] = НСтр("ru='Превышено количество запросов'");
	ПредставленияКодов[4] = НСтр("ru='Ожидание перед повторным запросом'");
	ПредставленияКодов[401] = НСтр("ru='Неверный токен сервиса'");
	ПредставленияКодов[5] = НСтр("ru='Прочее'");
	
	Возврат СтрШаблон("%1 (%2)", ПредставленияКодов[СыройОтвет.code], СыройОтвет.data);
КонецФункции

Функция ДанныеОЧекеДляПередачиНаКлиент(ДанныеОЧеке)
	ДанныеОЧеке.Товары = ОбщегоНазначения.ТаблицаЗначенийВМассив(ДанныеОЧеке.Товары);
	Возврат ДанныеОЧеке;
КонецФункции

Функция Токен()
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ПолучитьФункциональнуюОпцию("СервисЗаполненияРасходовИзЧеков") Тогда
		ВызватьИсключение НСтр("ru='Сервис отключен, получение токена невозможно'");
	КонецЕсли;
	
	Возврат ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища("СервисЗаполненияРасходовИзЧеков", "Токен");
КонецФункции

Процедура ЗаписатьТокен(Токен) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не Константы.СервисЗаполненияРасходовИзЧеков.Получить() Тогда
		ВызватьИсключение НСтр("ru='Сервис отключен, запись нового токена невозможна'");
	КонецЕсли;
	
	ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище("СервисЗаполненияРасходовИзЧеков", Токен, "Токен");
КонецПроцедуры

#КонецОбласти
